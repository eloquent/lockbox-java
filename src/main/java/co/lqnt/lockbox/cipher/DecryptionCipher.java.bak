/*
 * This file is part of the Lockbox package.
 *
 * Copyright Â© 2014 Erin Millard
 *
 * For the full copyright and license information, please view the LICENSE file
 * that was distributed with this source code.
 */

package co.lqnt.lockbox.cipher;

import co.lqnt.lockbox.cipher.parameters.KeyDecryptionCipherParametersInterface;
import java.nio.ByteBuffer;
import org.bouncycastle.crypto.BufferedBlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.engines.AESEngine;
import org.bouncycastle.crypto.macs.HMac;
import org.bouncycastle.crypto.modes.CBCBlockCipher;
import org.bouncycastle.crypto.paddings.PKCS7Padding;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;

/**
 * The key decryption cipher.
 */
public class KeyDecryptionCipher extends BufferedBlockCipher implements
    CipherInterface
{
    /**
     * Create a new key decryption cipher.
     */
    public KeyDecryptionCipher()
    {
        this.internalCipher = new PaddedBufferedBlockCipher(
            new CBCBlockCipher(new AESEngine()),
            new PKCS7Padding()
        );
        this.buffer = null;
        this.blockMac = null;
        this.finalMac = null;
        this.isHeaderReceived = false;
    }

    /**
     * Initialize the cipher.
     *
     * @param forEncryption True if the cipher should be initialized for encryption, false for decryption.
     * @param parameters    The parameters required by the cipher.
     *
     * @throws IllegalArgumentException If any argument is invalid.
     */
    @Override
    public void init(
        final boolean forEncryption,
        final CipherParameters parameters
    ) throws
        IllegalArgumentException
    {
        if (forEncryption) {
            throw new IllegalArgumentException(
                "This cipher only supports decryption."
            );
        }
        if (!(parameters instanceof KeyDecryptionCipherParametersInterface)) {
            throw new IllegalArgumentException(
                "Parameters must be an instance of " +
                    "KeyDecryptionCipherParametersInterface."
            );
        }

        this.parameters = (KeyDecryptionCipherParametersInterface) parameters;
        this.buffer = ByteBuffer
            .allocate(36 + this.parameters.key().authenticationSecretBytes());
        this.isHeaderReceived = false;
    }

    /**
     * Get the size of the output buffer required for an update() with an input
     * of the specified byte size.
     *
     * @param inputSize The input size in bytes.
     *
     * @return The output size in bytes.
     */
    @Override
    public int getUpdateOutputSize(final int inputSize)
    {
        int size = inputSize +
            this.buffer.position() -
            this.parameters.key().authenticationSecretBytes();

        if (!this.isHeaderReceived) {
            size -= 18;
        }

        size = (int) Math.floor(size / 18) * 16;

        return this.internalCipher.getUpdateOutputSize(size);
    }

    /**
     * Get the size of the output buffer required for an update() plus a
     * doFinal() with an input of the specified byte size.
     *
     * @param inputSize The input size in bytes.
     *
     * @return The output size in bytes.
     */
    @Override
    public int getOutputSize(final int inputSize)
    {
        int size = inputSize +
            this.buffer.position() -
            this.parameters.key().authenticationSecretBytes();

        if (!this.isHeaderReceived) {
            size -= 18;
        }

        size = (int) Math.floor(size / 18) * 16;

        return this.internalCipher.getOutputSize(size);
    }

    /**
     * Process a single byte, producing an output block if necessary.
     *
     * @param input        The input byte.
     * @param output       The space for any output that might be produced.
     * @param outputOffset The offset to which the output will be copied.
     *
     * @return The number of bytes produced.
     * @exception DataLengthException   If there isn't enough space in output.
     * @exception IllegalStateException If the cipher isn't initialized.
     */
    @Override
    public int processByte(
        final byte input,
        final byte[] output,
        final int outputOffset
    ) throws
        DataLengthException,
        IllegalStateException
    {
        return this.processBytes(new byte[]{input}, 0, 1, output, outputOffset);
    }

    /**
     * Process an array of bytes, producing an output block if necessary.
     *
     * @param input        The input byte array.
     * @param inputOffset  The offset at which the input data starts.
     * @param size         The number of bytes to be read from the input array.
     * @param output       The space for any output that might be produced.
     * @param outputOffset The offset to which the output will be copied.
     *
     * @return The number of bytes produced.
     * @exception DataLengthException   If there isn't enough space in output.
     * @exception IllegalStateException If the cipher isn't initialized.
     */
    @Override
    public int processBytes(
        final byte[] input,
        final int inputOffset,
        final int size,
        final byte[] output,
        final int outputOffset
    ) throws
        DataLengthException,
        IllegalStateException
    {
//        if (null == this.iv) {
//            throw new IllegalStateException("Cipher not initialized.");
//        }
//
//        int outputSize = this.getUpdateOutputSize(size);
//        int ciphertextOffset = outputOffset +
//            this.handleHeader(output, outputOffset, outputSize);
//
//        this.internalCipher.processBytes(
//            input,
//            inputOffset,
//            size,
//            output,
//            ciphertextOffset
//        );
//
//        if (outputSize > 0) {
//            int ciphertextSize = outputSize;
//
//            if (!this.isHeaderSent) {
//                this.isHeaderSent = true;
//                ciphertextSize -= 18;
//            }
//
//            this.authenticate(output, ciphertextOffset, ciphertextSize);
//        }
//
//        return outputSize;
    }

    /**
     * Process the last block in the buffer.
     *
     * @param output       The space for any output that might be produced.
     * @param outputOffset The offset to which the output will be copied.
     *
     * @return The number of bytes produced.
     * @exception DataLengthException        If there isn't enough space in output.
     * @exception IllegalStateException      If the cipher isn't initialized.
     * @exception InvalidCipherTextException If decryption fails.
     */
    @Override
    public int doFinal(
        final byte[] output,
        final int outputOffset
    ) throws
        DataLengthException,
        IllegalStateException,
        InvalidCipherTextException
    {
//        if (null == this.iv) {
//            throw new IllegalStateException("Cipher not initialized.");
//        }
//
//        int outputSize = this.getOutputSize(0);
//        int ciphertextOffset = outputOffset +
//            this.handleHeader(output, outputOffset, outputSize);
//
//        this.internalCipher.doFinal(output, ciphertextOffset);
//
//        int ciphertextSize;
//        if (outputSize > 0) {
//            ciphertextSize = outputSize - this.finalMac.getMacSize();
//
//            if (!this.isHeaderSent) {
//                this.isHeaderSent = true;
//                ciphertextSize -= 18;
//            }
//
//            this.authenticate(output, ciphertextOffset, ciphertextSize);
//        } else {
//            ciphertextSize = 0;
//        }
//
//        byte[] mac = new byte[this.finalMac.getMacSize()];
//        this.finalMac.doFinal(mac, 0);
//
//        System.arraycopy(
//            mac,
//            0,
//            output,
//            ciphertextOffset + ciphertextSize,
//            mac.length
//        );
//
//        return outputSize;
    }

    /**
     * Reset the cipher to its state after the last init() call.
     */
    @Override
    public void reset()
    {
        this.internalCipher.reset();
        this.buffer = ByteBuffer
            .allocate(36 + this.parameters.key().authenticationSecretBytes());
        this.isHeaderReceived = false;
    }

    final private PaddedBufferedBlockCipher internalCipher;
    private KeyDecryptionCipherParametersInterface parameters;
    private ByteBuffer buffer;
    private HMac blockMac;
    private HMac finalMac;
    private boolean isHeaderReceived;
}
