# Lockbox for Java

*Simple, strong encryption.*

[![Build status]][Latest build]
[![Test coverage]][Test coverage report]
[![Uses semantic versioning]][SemVer]

## Installation and documentation

* Available soon via the Maven central repository.
* [API documentation] available.

## What is *Lockbox*?

*Lockbox* is the simplest possible way to implement strong, two-way, public-key
encryption for use in applications. *Lockbox* uses a combination of
well-established technologies to ensure the safety of data. For more
information, see the [Lockbox website].

## Usage

### Generating keys via OpenSSL

*Lockbox* uses [RSA] keys in [PEM] format. This is a standard format understood
by [OpenSSL]. Generating of keys is normally handled by the `openssl` command
line tool (although *Lockbox* can also generate keys programmatically).
Generating a 2048-bit private key can be achieved with this command:

    openssl genrsa -out private.pem 2048

Private keys can have password protection. To create a key with a password,
simply add the `-des3` flag, which will prompt for password input before the key
is created:

    openssl genrsa -des3 -out private.pem 2048

This private key must be kept secret, and treated as sensitive data. Private
keys are the only keys capable of decrypting data. Public keys, on the other
hand, are not as sensitive, and can be given to any party that will be
responsible for encrypting data.

*Lockbox* is capable of extracting public keys from private keys, there is no
need to create matching public key files; but if for some reason a public key
file is required, this command will create one:

    openssl rsa -pubout -in private.pem -out public.pem

### Generating keys programmatically

**Note:** Keys generated by *Lockbox* can easily be converted for use with
either [Bouncy Castle] or [JCE]. Check the [PrivateKey] and [PublicKey] API
documentation for more information.

```java
import co.lqnt.lockbox.key.KeyFactory;
import co.lqnt.lockbox.key.PrivateKey;
import co.lqnt.lockbox.key.PublicKey;

// ...

KeyFactory keyFactory = new KeyFactory();

PrivateKey privateKey = keyFactory.generatePrivateKey();
System.out.println(privateKey.toString()); // outputs the key in PEM format

PublicKey publicKey = privateKey.publicKey();
System.out.println(publicKey.toString()); // outputs the key in PEM format

// ...
```

### Encrypting data

**Note:** Encryption only requires a public key, but *Lockbox* will also accept
private keys, as in this example.

```java
import co.lqnt.lockbox.EncryptionCipher;
import co.lqnt.lockbox.key.exception.PrivateKeyReadException;
import co.lqnt.lockbox.key.KeyFactory;
import co.lqnt.lockbox.key.PrivateKey;
import java.io.File;

// ...

String data = "Super secret data.";

KeyFactory keyFactory = new KeyFactory();
PrivateKey key;
try {
    key = keyFactory.createPrivateKey(new File("/path/to/key.pem"), "password");
} catch (PrivateKeyReadException e) {
    throw new RuntimeException("MISSION ABORT!", e); // this could be handled much better...
}

EncryptionCipher cipher = new EncryptionCipher();
String encrypted = cipher.encrypt(key, data);

// ...
```

### Encrypting multiple data packets with the same key

*Lockbox* includes 'bound' ciphers that are locked to a particular key. These
type of ciphers are convenient for encrypting multiple data packets.

**Note:** Encryption only requires a public key, but *Lockbox* will also accept
private keys, as in this example.

```java
import co.lqnt.lockbox.BoundEncryptionCipher;
import co.lqnt.lockbox.key.exception.PrivateKeyReadException;
import co.lqnt.lockbox.key.KeyFactory;
import co.lqnt.lockbox.key.PrivateKey;
import java.io.File;

// ...

String[] data = new String[] {
    "Super secret data.",
    "Extra secret data.",
    "Mega secret data."
};

KeyFactory keyFactory = new KeyFactory();
PrivateKey key;
try {
    key = keyFactory.createPrivateKey(new File("/path/to/key.pem"), "password");
} catch (PrivateKeyReadException e) {
    throw new RuntimeException("MISSION ABORT!", e); // this could be handled much better...
}

BoundEncryptionCipher cipher = new BoundEncryptionCipher(key);

String[] encrypted = new String[data.length];
for (int i = 0; i < data.length; ++i) {
    encrypted[i] = cipher.encrypt(data[i]);
}

// ...
```

### Decrypting data

```java
import co.lqnt.lockbox.DecryptionCipher;
import co.lqnt.lockbox.exception.DecryptionFailedException;
import co.lqnt.lockbox.key.exception.PrivateKeyReadException;
import co.lqnt.lockbox.key.KeyFactory;
import co.lqnt.lockbox.key.PrivateKey;
import java.io.File;

// ...

String encrypted = "<some encrypted data>";

KeyFactory keyFactory = new KeyFactory();
PrivateKey key;
try {
    key = keyFactory.createPrivateKey(new File("/path/to/key.pem"), "password");
} catch (PrivateKeyReadException e) {
    throw new RuntimeException("MISSION ABORT!", e); // this could be handled much better...
}

DecryptionCipher cipher = new DecryptionCipher();

String data;
try {
    data = cipher.decrypt(key, encrypted);
} catch (DecryptionFailedException e) {
    // decryption failed
}

// ...
```

### Decrypting multiple data packets with the same key

*Lockbox* includes 'bound' ciphers that are locked to a particular key. These
type of ciphers are convenient for decrypting multiple data packets.

```java
import co.lqnt.lockbox.BoundDecryptionCipher;
import co.lqnt.lockbox.exception.DecryptionFailedException;
import co.lqnt.lockbox.key.exception.PrivateKeyReadException;
import co.lqnt.lockbox.key.KeyFactory;
import co.lqnt.lockbox.key.PrivateKey;
import java.io.File;

// ...

String[] encrypted = new String[] {
    "<some encrypted data>",
    "<more encrypted data>",
    "<other encrypted data>"
};

KeyFactory keyFactory = new KeyFactory();
PrivateKey key;
try {
    key = keyFactory.createPrivateKey(new File("/path/to/key.pem"), "password");
} catch (PrivateKeyReadException e) {
    throw new RuntimeException("MISSION ABORT!", e); // this could be handled much better...
}

BoundDecryptionCipher cipher = new BoundDecryptionCipher(key);

String[] data = new String[encrypted.length];
for (int i = 0; i < encrypted.length; ++i) {
    try {
        data[i] = cipher.decrypt(encrypted[i]);
    } catch (DecryptionFailedException e) {
        // decryption failed
    }
}

// ...
```

<!-- References -->

[Bouncy Castle]: http://www.bouncycastle.org/java.html
[JCE]: http://en.wikipedia.org/wiki/Java_Cryptography_Extension
[Lockbox website]: http://lqnt.co/lockbox
[OpenSSL]: http://en.wikipedia.org/wiki/OpenSSL
[PEM]: http://en.wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail
[PrivateKey]: http://eloquent-software.com/lockbox-java/artifacts/documentation/api/co/lqnt/lockbox/key/PrivateKey.html
[PublicKey]: http://eloquent-software.com/lockbox-java/artifacts/documentation/api/co/lqnt/lockbox/key/PublicKey.html
[RSA]: http://en.wikipedia.org/wiki/RSA_(algorithm)

[API documentation]: http://lqnt.co/lockbox-java/artifacts/documentation/api/
[Build status]: https://api.travis-ci.org/eloquent/lockbox-java.png?branch=master
[Latest build]: https://travis-ci.org/eloquent/lockbox-java
[SemVer]: http://semver.org/
[Test coverage report]: https://coveralls.io/r/eloquent/lockbox-java
[Test coverage]: https://coveralls.io/repos/eloquent/lockbox-java/badge.png?branch=master
[Uses semantic versioning]: http://b.repl.ca/v1/semver-yes-brightgreen.png
